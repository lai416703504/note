# 打造扛得住的MySQL数据库架构

## 第一章 实例和故事

### 1-1 什么决定了电商双11大促的成败

web服务器可以随意扩展


数据库无法随意扩展 数据库具有 完整性和一致性

### 在双11大促中的数据库服务器

#### 历史的数据库架构
+ 1 台 Master -> 15 台 Slave
+ 没有主从复制的组件
+ 需要手动把 有相对最新数据的从服务器 转为主服务器
+ 手动转换相当耗时

#### 监控信息(影响数据库性能)
最高峰 35W次 QPS&TPS
最大值 700 并发量
磁盘IO 能力要高
> 最好不要在主库上数据库备份
>
> 有大型活动前取消这类计划

### 1-3 在大促中什么影响了数据库性能

#### 影响数据库的因素
+ sql查询速度
+ 服务器硬件
+ 网卡流量
+ 磁盘IO


##### 效率低下的SQL


##### 大量的并发和超高的CPU使用率
> 风险：
>
>     大量的并发：数据库连接数被占满(max_connections默认100 生产环境要改大)
>
>     超高的CPU使用率： 因CPU资源耗尽而出现宕机

##### 磁盘IO
> 风险：
>
>     磁盘IO性能突然下降(使用更快的磁盘设备)
>
>     其他大量消耗磁盘性能的计划任务（调整计划任务,做好磁盘维护）

##### 网卡流量
> 风险：
>
>     网卡IO被占满（1000Mb/8 ≈ 100MB）
> 如何避免无法连接数据库的情况
>1. 减少从服务器的数量
>2. 进行分级缓存
>3. 避免使用"``` select * ```"进行查询
>4. 分离业务网络和服务器网络


### 1-4 大表带来的问题
#### 什么样的表称为大表 ？
+ 记录行数巨大，单表超过千万行
+ 表数据文件巨大，表数据文件超过10G
+ 以上只是理论上，日志表就算超过千万行也对业务无影响，要根据实际例子

#### 大表对查询的影响
+ 慢查询：很难在一定的时间内过滤出所需要的数据

#### 大表对DDL操作的影响
+ 建立索引需要很长的时间
>风险:
>
> MySQL版本<5.5 建立索引会锁表
>
> MySQL版本>=5.5 虽然不会锁表但会引起主从延迟
+ 修改表结构需要长时间锁表
>风险:
>
> 会造成长时间的主从延迟
>
> 影响正常的数据操作

#### 如何处理数据库中的大表
+ 分库分表把一张大表分成多个小表
>难点:
>
> 分表主键的选择
>
> 分表后跨分区数据的查询和统计
+ 大表的历史数据归档 <font color="red">减少对前后端业务的影响</font>
> 难点:
>
> 归档时间点的选择
>
> 如何进行归档操作

### 1-5 大事务带来的问题
#### 什么是事务
1. 事务是数据库系统区别于其他一切文件系统的重要特性之一
2. 事务是一组具有原子性的SQL语句，或是一个独立的工作单元

事务具有以下特性
+ 原子性
+ 一致性
+ 隔离性
+ 持久性

##### 事务的原子性(ATOMICITY)
> 定义：
>
> 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作

>例:
> 1. 检查理财账户中余额是否高于2000元
> 2. 从理财账户的余额中减去2000元
> 3. 在活动存款账户上增加2000元
>
> 这三步不管哪步崩溃都无法进行

##### 事务的一致性(CONSISTENCY)
> 定义：
>
> 一致性是指事务将数据库从一种一致性状态转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中的数据完整性没有被破坏

>例:
>
>还是原来的例子，总的账户余额保持一致，就叫做一致性。


##### 事务的隔离性(ISOLATION)
> 定义：
>
> 隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其它事务是不可见的

> 例:
>
> 还是原来的例子，在转账还未完成时，还是能看到理财账户中的2000元
###### &nbsp;&nbsp;&nbsp;&nbsp; SQL标准定义的四种隔离级别
+ 未提交读(READ UNCOMMITED)（脏读）
+ 已提交写(READ COMMITED)一般的SQL数据库的级别 （这就是不可重复读）
+ 可重复读(REPEATABLE READ)
+ 可串行化(SERIALIZABLE) 很少用，因为容易锁
+ 1-4 隔离性由低到高  1-4 并发性由高到低

##### 事务的持久性(DURABILITY)
> 定义：
>
> 一旦事务提交，这其所作的修改就会永久保存到数据库中。<br/>
> 此时即使系统崩溃，已经提交的修改数据也不会丢失。

#### 什么是大事务
> 定义：
>
> 运行时间比较长，操作的数据比较多的事务

> 风险:
>
> 锁定太多的数据，造成大量的阻塞和锁超时
>
> 回滚时所需的时间比较长
>
> 执行时间长，容易造成主从延迟

#### 如何处理大事务
1. 避免一次处理太多的数据
2. 移出不必要在事务中的SELECT操作

### 总结
+ 直观的展示了数据库在繁忙时的系统状态
+ 简单了解了对性能有影响的一些因素

## 第二章 什么影响了MySQL性能
### 2-1 影响性能的几个方面
1. 硬件-------cpu 内存 磁盘IO
2. 操作系统
3. 数据库存储引擎的选择
> MySQL的最大特点是插件式存储引擎
>
> MyISAM:不支持事务，表级锁。<br/>
> InnoDB:事务存储引擎，完美支持行级锁，事务ACID特性。
4. 数据库参数配置 (DBA要懂) 前3项的影响加起来也许都没第4项的影响大
5. 数据库结构设计和SQL语句（<font color="red">重点</font>）

### 2-2 CPU资源和可用内存大小
#### 如何选择CPU？
+ 我的应用是CPU密集型的吗？
> MySQL不支持多CPU对同一SQL并发处理
+ 我们系统的并发量如何？
> 1 \* CPU -> 1 \* SQL<br/>
> 40 \* CPU -> 40 \* SQL<br/>
>QPS是秒级的，SQL一般是毫秒或者纳秒级别的<br/>
>web应用中一般并发量比较高，核心数量比频率重要

+ 我们使用的MySQL的版本

>老版本对多核CPU支持很差<br/>
>5.6-5.7对多核CPU支持有所改善

+ 选择32位还是64位CPU？（现在没啥32位了吧）

> 现在想买32位CPU可能都买不到了<br/>
> 64位CPU使用32位的服务器版本

#### 内存
目前内存速度还是大于SSD的

+ MYSIAM对内存的缓存
![内存对MYISAM](http://image.laihongji.com/4.png)

+ InnoDB数据对内存的缓存
![内存对InnoDB](http://image.laihongji.com/5.png)
>提示:
>
>内存越多越好，但对性能影响有限,并不能无限的增加性能。数据库能使用的内存是有限，如果它所有的数据都缓存到内存中则再加内存也没有意义。<br/>
不过多余的内存增加操作系统等其他服务的性能

### 2-3 磁盘的配置和选择
1. 使用传统机器硬盘
2. 使用 RAID 增强传统机器硬盘的性能
3. 使用固态存储 SSD 和 PCIe 卡
4. 使用网络存储 NAS 和 SAN

#### 传统磁盘
+ 最常见
+ 使用最多
+ 价格低
+ 存储空间大
+ 读、写较慢

##### 传统机器硬盘读取数据的过程
1. 移动磁头到磁盘表面上等正确位置
2. 等待磁盘旋转，使的所需的数据在磁头之下
3. 等待磁盘旋转过去，所有所需的数据都被磁头读出

##### 如何选择传统机器硬盘
1. 存储容量
2. 传输速度（也就是上面的第三步）
3. 访问时间
4. 主轴转速
5. 物理尺寸

### 2-4 使用 RAID 增强传统机器硬盘的性能
#### 什么是RAID
> RAID是磁盘冗余队列的简称(Redundant arrays of Independent Disk)<br/>
> 简单来说RAID的作用就是可以把多个容量较小的磁盘组成一组容量更大的磁盘，并提供数据冗余来保证数据的完整性的技术

#### RAID 0---常用的RAID组别
> RAID 0 是最早出现的RAID模式，也称为数据条带。是组建磁盘阵列中<font color="red">最简单</font>的一种形式，只需要2块以上的磁盘即可，<font color="red">成本低</font>，可以提高整个磁盘的性能和吞吐量。RAID 0 <font color="red">没有提供冗余或错误修复能力</font>，但是实现成本是最低的。

#### RAID 1---常用的RAID组别
> RAID 1 又称<font color="red">磁盘镜像</font>,原理是把一个磁盘的数据镜像到另一个磁盘上，也就是说数据在写入一块磁盘的同时，会在另一块闲置的磁盘上生成镜像文件，在不影响性能情况下<font color="red">最大限度的保证系统的可靠性和可修复性</font>。

#### RAID 5---常用的RAID组别
> RAID 5 又称为分布式奇偶校验的独立磁盘阵列<br/>
通过分布式奇偶校验块把<font color="red">数据分散到多个磁盘</font>上，这样如果任何一个盘数据失效，都可以从奇偶校验块中重建。但是如果两块磁盘失效，则整个卷的数据都无法恢复。

#### RAID 10---常用的RAID组别
> RAID 10 又称为分片的镜像<br/>
它是对磁盘先做 RAID 1 之后对两组 RAID 1 的磁盘再做 RAID 0 , 所以对读写都有良好的性能，相对于 RAID 5 重建起来更简单,速度也更快。


#### RAID 级别的选择
|等级|特点|是否冗余|盘数|读|写|
|::|::|::|::|::|::|::|::|
|RAID0|便宜,快速,危险|否|N|快|快|
|RAID1|高速读,简单,安全|有|2|快|慢|
|RAID5|安全,成本折中|有|N+1|快|取决于最慢的盘|
|RAID10|贵,高速,安全|有|2N|快|快|

>主库一般使用 RAID 10 从库使用 RAID 0 或 RAID 5

### 2-5 使用固态存储 SSD 或 PCIe 卡
> 固态存储也称为闪存(Flash Memory)

#### 特点
+ 相比机械硬盘固态磁盘有更好的随机读写性能
+ 相比机械磁盘固态磁盘能更好的支持并发
+ 相比机械磁盘固态磁盘更容易损坏（<font color="red">缺点</font>）

#### SSD(固态硬盘)的特点
1. 使用 SATA 接口 可以替换传统磁盘而不需要任何改变
2. SATA 接口的 SSD 同样支持 RAID 技术

#### PCIe SSD(Fusion-IO)卡的特点
1. 无法使用 SATA 接口 需要独特的驱动和配置
2. 价格相对于SSD更贵 性能比SSD更好

#### 固态存储的使用场景
+ 适用于存在大量随机I/O的场景
+ 使用于解决单线程负载的I/O瓶颈

### 2-6 使用网络存储 SAN 和 NAS
> SAN(Storage Area Network) 和 NAS(Network-Attached Storage)是两种外部文件存储设备加载到服务器上的方法

#### SAN
+ SAN 设备通过光纤连接到服务器，设备通过接口访问，服务器可以将其当做硬盘使用
+ 大量顺序读写、读写I/O、缓存、I/O合并、随机读写慢、不如本地RAID磁盘

#### NAS
+ NAS 设备使用网络连接，通过基于文件的协议如 NFS 或 SMB 来访问

#### 网络存储使用的场景
+ 数据库备份

#### 网络对性能的影响
+ 网络带宽对性能的影响
  + 延迟
  + 吞吐量（带宽）
+ 网络质量对性能的影响
> 建议<br/>
>+ 采用高性能和高带宽的网络接口设备和交换机
>+ 对多个网卡进行绑定，增强可用性和带宽
>+ 尽可能的进行网络隔离

### 2-7 总结：服务器硬件对性能的影响
+ CPU
  + 64位CPU一定要工作在64位的系统下
  + 对于并发比较高的场景 CPU 的数量比频率重要
  + 对于 CPU 密集性场景和复杂SQL则频率越高越好
+ 内存
  + 选择主板能使用的最高频率的内存
  + 内存的大小对性能很重要，所以尽可能的大
+ I/O子系统
  + PCIe->SSD->RAID10->磁盘->SAN
+ 网络

### 2-8 操作系统对性能的影响-MySQL适合的操作系统
#### MySQL适合的操作系统
+ Windows(大小写)
+ FreeBSD(老版本对MySQL的支持不是很好)
+ Solaris(原来只能在SUM公司下的机器运行，现在可以在X86下运行了)
+ Linux

### 2-9 CentOS 系统参数优化
#### 影响重大的a tiile 优化参数
+ 内核相关参数(/etc/sysctl.conf)<br>

增加连接数
    + net.core.somaxconn=65535
    + net.core.netdev_max_backlog=65535
    + net.ipv4.tcp_max_syn_backlog=65535

加快TCP回收效率
    + net.ipv4.tcp_fin_timeout=10
    + net.ipv4.tcp_tw_reuse=1
    + net.ipv4.tcp_tw_recycle=1

缓冲区接受的默认值和最大值
    + net.core.wmem_default=87380
    + net.core.wmem_max=16777216
    + net.core.rmem_default=87380
    + net.core.rmem_max=16777216

失效连接所占用TCP系统资源，加快系统回收的效率
    + net.ipv4.tcp_keepalive_time=120
    + net.ipv4.tcp_keepalive_intvl=30
    + net.ipv4.tcp_keepalive_probes=3
内存相关的参数
    + kernel.shmmax=4294967295
    Linux 内核参数中最重要的参数之一，用于定义单个共享内存段的最大值。
    > 注意：
        1. 这个参数应该设置的足够大，以便能在一个共享内存段下容纳下整个的Innodb缓冲池的大小。
        2. 这个值的大小对于64位linux系统，可取的最大值为物理内存值-1byte，建议值为大于物理内存的一半，一半取值大于Innodb 缓着冲池的大小即可，可以去物理内存-1byte。

    + vm.swappiness=0
    这个参数当内存不足时会对性能参数比较明显的影响
    Linux系统内存交换区:
      在Linux系统安装时都会有一个特殊的磁盘分区，称之为系统交换分区。
      使用 free -m 在系统中可以看到类似下面内容其中swap就是交换分区。
      当操作系统因为没有足够内存时就会将一些<font color="red">虚拟内存</font>写到<font color="red">磁盘的交换区</font>中这样就会发生内存交换
    在MySQL服务器上是否要使用交换分区有一些争议:
      在MySQL服务所在的Linux系统上完全禁用交换分区。
      带来的风险：
        1. 降低操作系统的性能
        2. 容易造成内存溢出、崩溃，或都被操作系统Kill掉
    结论：
      在MySQL服务器上保留交换区还是很必要的，但是要控制何时使用交换分区
    vm.swappiness=0就是告诉Linux内核除非虚拟内存完全满了，否则不要使用交换区。
+ 增加资源限制(/etc/security/limit.conf)
      这个文件实际上是Linux PAM 也就是插入式认证模块的配置文件。
      打开文件数的限制。

      * soft nofile 65535
      * hard nofile 65535
      加到limit.conf 文件末尾就可以了

      *       表示对所有用户有效
      soft    指的是当前系统生效的设置
      hard    表明系统中能设定的最大值
      nofile  表示所限制的资源是打开文件的最大数目
      65535   就是限制的数量
      结论：
        把可打开的文件数量增加到了65535个以保证可以打开足够多的文件句柄。
      注意：
        这个文件的修改需要重启系统才可以生效。
+ 磁盘调度策略(/sys/block/devname/queue/scheduler)
      cat /sys/block/sda/queue/scheduler
      noop anticipatory deadline [cfq]
      noop(电梯式调度策略)
        NOOP实现了一个FIFO队列，它像电梯的工作方法一样对I/O请求进行组织，当
        有一个新的请求到来时，它将强求合并最近的请求之后，以此来保证请求同一
        介质。NOOP倾向饿死读而利于写，因此NOOP对于闪存设备、RAM及嵌入式系统
        是最好的选择。
      deadline(截止时间调度策略)  
        Deadline确保了再一个截止时间内服务请求，这个截止时间是可调整的，而
        默认读期限短语写期限。这样就防止了写操作因为不能被读取而饿死的现象，
        Deadline对数据库类应用是最好的选择。
      anticipatory(预料I/O调度策略)
        本质上与Deadline一样，但在最后一次读操作后，要等6ms，才能继续进行对
        其它I/O请求进行调度。他会在每个6ms中插入行的I/O操作，而会将一些小写
        入流合并成一个大写入流，用写入延时换区最大的写入吞吐量。AS适合于*写
        入较多的环境*，比如文件服务器，AS对数据库环境表现很差。

### 2-10 文件系统
